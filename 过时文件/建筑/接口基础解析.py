import 日志
import 建筑.通用 as 建筑通用
import 建筑.无带 as 建筑无带
import 文件.通用 as 文件函数

# TODO：记得把部分警告切割出去单独做一个文件

# 任何建筑，可以由自身主导一次单一输入 + 单一输出
# 但不能同时主导多个输入或多个输出
# 比如小矿机可以输出到传送带，依靠自身
# 但大矿机不行，因为他有多个口，他的输出由传送带主导
# 本文件只做由自身主导的解析



# 连接类型：传送带、分拣器、堆叠


def 解析单个传送带输出接口(该传送带, 所有建筑):
    # outputObjIdx = 该传送带向xx目标输出，可以是传送带，也可以是建筑
    # 起个别名，省的太长

    # outputObjIdx = 该分拣器向xx目标输出
    解析["输出"] = 解析.pop("out")
    解析 = 该传送带["一级接口解析"]
    解析["输出目标ID"] = 该传送带['outputObjIdx']

    if 解析["输出目标ID"] == -1:
        解析["输出目标类型"] = "空"
        return
    输出目标 = 所有建筑[解析["输出目标ID"]]
    从自身的xx口输出 = 该传送带['outputFromSlot']
    向目标的xx口输出 = 该传送带['outputToSlot']

    if not 建筑通用.是传送带吗(输出目标):
        该传送带["一级接口解析"]["输出目标类型"] = "普通建筑"
    elif 从自身的xx口输出 == 0 and 向目标的xx口输出 == 1:
        该传送带["一级接口解析"]["输出目标类型"] = "主带"
    # 位于-1到3之间
    elif 从自身的xx口输出 == 0 and 向目标的xx口输出 in [2, 3]:
        该传送带["一级接口解析"]["输出目标类型"] = "并带"
    else:
        日志.警告("传送带的outputFromSlot和outputToSlot不符合预期")
    # 分拣器也不应该，但我不知道会不会有额外收益或危害,所以懒得写

def 解析单个传送带输入接口(该传送带, 所有建筑):
     # inputObjIdx = 该传送带从xx目标输入，不是传送带，而是某个是建筑
    # inputObjIdx = 该分拣器从xx目标获取
    解析 = 该传送带["一级接口解析"]
    解析["获取"] = 解析.pop("in")
    该传送带["一级接口解析"]["输入目标ID"] = 该传送带['inputObjIdx']
    if 该传送带["一级接口解析"]["输入目标ID"] == -1:
        return

    输入目标 = 所有建筑[该传送带["一级接口解析"]["输入目标ID"]]
    if 建筑通用.是传送带吗(输入目标):
        日志.警告("传送带的inputObjIdx不应该为传送带")
    

def 解析单个传送带接口(该传送带, 所有建筑):
    该传送带["一级接口解析"] = {}
    该传送带["一级接口解析"]["本建筑类型"] = "传送带"

    # 传送带不记录上个传送带，只记录下个
    解析单个传送带输出接口(该传送带, 所有建筑)
    解析单个传送带输入接口(该传送带, 所有建筑)


def 解析单个分拣器接口(该分拣器, 所有建筑):
    解析 = 该分拣器["一级接口解析"]
    解析["连接类型"] = "一般建筑"
    # inputObjIdx = 该分拣器从xx目标获取
    解析["获取"] = 解析.pop("in")
    # outputObjIdx = 该分拣器向xx目标输出
    解析["输出"] = 解析.pop("out")
    # 这两行告警了100%是仙术导致的，虽然没啥问题
    if 该分拣器['outputFromSlot'] != 0:
        日志.警告("分拣器应该从自身的0号口输出，虽然没有危害")
    if 该分拣器['inputToSlot'] != 1:
        日志.警告("分拣器应该向自身的1号口输入，虽然没有危害")
    # 输入输出的建筑类型不解析了，到时候还要再解析一遍

def 解析单个普通建筑接口(该建筑, 所有建筑):
    解析 = 该建筑["一级接口解析"]
    解析["连接类型"] = "一般建筑"
    # inputObjIdx = 向目标堆叠
    解析["堆叠"] = 解析.pop("in")
    # outputObjIdx = 向单一目标输出（如矿机）
    解析["输出"] = 解析.pop("out")
    if 该建筑["inputObjIdx"] == -1:
        pass
    elif 该建筑['inputFromSlot'] != 15:
        日志.警告("建筑应该从别人的的15号口堆叠，虽然危害较小")
    elif 该建筑['inputToSlot'] != 14:
        日志.警告("建筑应该从自身的的14号口堆叠，虽然危害较小")

def 解析单个建筑接口(该建筑, 所有建筑):
    该建筑["一级接口解析"] = {}
    解析 = 该建筑["一级接口解析"]
    解析["in"] = {}
    解析["in"]["目标ID"] = 该建筑['inputObjIdx']
    解析["in"]["自身接口"] = 该建筑['inputToSlot']
    解析["in"]["目标接口"] = 该建筑['inputFromSlot']

    解析["out"] = {}
    解析["out"]["目标ID"] = 该建筑['outputObjIdx']
    解析["out"]["自身接口"] = 该建筑['outputToSlot']
    解析["out"]["目标接口"] = 该建筑['outputFromSlot']

    if 建筑通用.是传送带吗(该建筑):
        return 解析单个传送带接口(该建筑, 所有建筑)
    elif 建筑通用.是分拣器吗(该建筑):
        return 解析单个分拣器接口(该建筑, 所有建筑)
    else:
        return 解析单个普通建筑接口(该建筑, 所有建筑)

def 解析建筑接口(所有建筑):
    for 建筑 in 所有建筑:
        解析单个建筑接口(建筑, 所有建筑)

if __name__ == '__main__':
    import sys
    蓝图 = 文件函数.读取文件(sys.argv[1])
    解析建筑接口(蓝图['buildings'])
    文件函数.保存文件(sys.argv[2], 蓝图)
